<!DOCTYPE html>


  <html class="light page-post">


<head>
  <!-- 代码块的高亮 -->
  <link rel="stylesheet" href="//cdn.bootcss.com/highlight.js/9.2.0/styles/rainbow.min.css">
  <script src="//cdn.bootcss.com/highlight.js/9.2.0/highlight.min.js"></script>
  <script>hljs.initHighlightingOnLoad();</script>

  <!-- <link<! rel="stylesheet" href="/path/to/styles/default.css"> -->
  <!-- <script src="/path/to/highlight.pack.js"></script> -->
  <!-- <script>hljs.initHighlightingOnLoad();</script> -->


  <meta charset="utf-8">
  
  <title>iOS多线程 | 我的博客地址</title>

  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

  
    <meta name="keywords" content="基础知识," />
  

  <meta name="description" content="iOS开发多线程首先我们来搞清楚几个概念和他们之间的联系和区别:  多线程开发常用概念 进程和线程  进程是具有一定独立功能的程序关于某个数据集合上的一次运行活动, 进程是系统进行资源分配和调度的一个独立单位.   线程是进程的一个实体, 是CPU调度和分派(资源分配)的基本单位, 它是比进程更小的能独立运行的基本单位. 线程自己基本上不拥有系统资源, 只拥有一点在运行中必不可少的资源(如程序计数">
<meta name="keywords" content="基础知识">
<meta property="og:type" content="article">
<meta property="og:title" content="iOS多线程">
<meta property="og:url" content="http://hchong.net/2017/11/21/iOS多线程/index.html">
<meta property="og:site_name" content="我的博客地址">
<meta property="og:description" content="iOS开发多线程首先我们来搞清楚几个概念和他们之间的联系和区别:  多线程开发常用概念 进程和线程  进程是具有一定独立功能的程序关于某个数据集合上的一次运行活动, 进程是系统进行资源分配和调度的一个独立单位.   线程是进程的一个实体, 是CPU调度和分派(资源分配)的基本单位, 它是比进程更小的能独立运行的基本单位. 线程自己基本上不拥有系统资源, 只拥有一点在运行中必不可少的资源(如程序计数">
<meta property="og:locale" content="zh-zh-Hans">
<meta property="og:image" content="http://img.souche.com/f2e/5d7717afde012bbfc557f26bc5eaffea.png">
<meta property="og:updated_time" content="2017-11-25T13:06:33.559Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="iOS多线程">
<meta name="twitter:description" content="iOS开发多线程首先我们来搞清楚几个概念和他们之间的联系和区别:  多线程开发常用概念 进程和线程  进程是具有一定独立功能的程序关于某个数据集合上的一次运行活动, 进程是系统进行资源分配和调度的一个独立单位.   线程是进程的一个实体, 是CPU调度和分派(资源分配)的基本单位, 它是比进程更小的能独立运行的基本单位. 线程自己基本上不拥有系统资源, 只拥有一点在运行中必不可少的资源(如程序计数">
<meta name="twitter:image" content="http://img.souche.com/f2e/5d7717afde012bbfc557f26bc5eaffea.png">

  

  
    <link rel="icon" href="/images/favicon.ico">
  

  <link href="/css/styles.css?v=d671a41f" rel="stylesheet">


  
    <link rel="stylesheet" href="/css/style.css">
  

  

  
  <script type="text/javascript">
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "//hm.baidu.com/hm.js?57e94d016e201fba3603a8a2b0263af0";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>



  
    <script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>
  

  
    <link rel="stylesheet" href="//cdn.bootcss.com/font-awesome/4.3.0/css/font-awesome.min.css">
  
</head>

<body>


  
    <span id="toolbox-mobile" class="toolbox-mobile">戳我</span>
  

  <div class="post-header CENTER">
   
  <div class="toolbox">
    <a class="toolbox-entry" href="/">
      <span class="toolbox-entry-text">戳我</span>
      <i class="icon-angle-down"></i>
      <i class="icon-home"></i>
    </a>
    <ul class="list-toolbox">
      
        <li class="item-toolbox">
          <a
            class="ROUND_RECT"
            href="/archives/"
            rel="noopener noreferrer"
            target="_self"
            >
            博客
          </a>
        </li>
      
        <li class="item-toolbox">
          <a
            class="ROUND_RECT"
            href="/category/"
            rel="noopener noreferrer"
            target="_self"
            >
            分类
          </a>
        </li>
      
        <li class="item-toolbox">
          <a
            class="ROUND_RECT"
            href="/tag/"
            rel="noopener noreferrer"
            target="_self"
            >
            标签
          </a>
        </li>
      
        <li class="item-toolbox">
          <a
            class="ROUND_RECT"
            href="/Wiki/"
            rel="noopener noreferrer"
            target="_self"
            >
            Wiki
          </a>
        </li>
      
        <li class="item-toolbox">
          <a
            class="ROUND_RECT"
            href="/about/"
            rel="noopener noreferrer"
            target="_self"
            >
            关于
          </a>
        </li>
      
        <li class="item-toolbox">
          <a
            class="ROUND_RECT"
            href="/search/"
            rel="noopener noreferrer"
            target="_self"
            >
            搜索
          </a>
        </li>
      
    </ul>
  </div>


</div>


  <div id="toc" class="toc-article">
    <strong class="toc-title">文章目录</strong>
    <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#iOS开发多线程"><span class="toc-text">iOS开发多线程</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#多线程开发常用概念"><span class="toc-text">多线程开发常用概念</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#多线程实现方案"><span class="toc-text">多线程实现方案</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Pthresds"><span class="toc-text">Pthresds</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#NSThread"><span class="toc-text">NSThread</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#GCD"><span class="toc-text">GCD</span></a></li></ol></li></ol></li></ol>
  </div>



<div class="content content-post CENTER">
   <article id="post-iOS多线程" class="article article-type-post" itemprop="blogPost">
  <header class="article-header">
    <h1 class="post-title">iOS多线程</h1>

    <div class="article-meta">
      <span>
        <i class="icon-calendar"></i>
        <span>2017.11.21</span>
      </span>

      
        <span class="article-author">
          <i class="icon-user"></i>
          <span>HChong</span>
        </span>
      

      
  <span class="article-category">
    <i class="icon-list"></i>
    <a class="article-category-link" href="/categories/基础知识/">基础知识</a>
  </span>



      
        <span>
          <i class="icon-comment"></i>
          <a href="http://www.hchong.net/2017/11/21/iOS多线程/#disqus_thread"></a>
        </span>
      

      
      <i class="fa fa-eye"></i> 
        <span id="busuanzi_container_page_pv">
           &nbsp热度 <span id="busuanzi_value_page_pv">
           <i class="fa fa-spinner fa-spin"></i></span>℃
        </span>
      

      
      
    </div>
  </header>

  <div class="article-content">
    
      <h1 id="iOS开发多线程"><a href="#iOS开发多线程" class="headerlink" title="iOS开发多线程"></a>iOS开发多线程</h1><p>首先我们来搞清楚几个概念和他们之间的联系和区别: </p>
<h2 id="多线程开发常用概念"><a href="#多线程开发常用概念" class="headerlink" title="多线程开发常用概念"></a>多线程开发常用概念</h2><ol>
<li><p>进程和线程</p>
<p> 进程是具有一定独立功能的程序关于某个数据集合上的一次运行活动, 进程是系统进行资源分配和调度的一个独立单位. </p>
<p> 线程是进程的一个实体, 是CPU调度和分派(资源分配)的基本单位, 它是比进程更小的能独立运行的基本单位. 线程自己基本上不拥有系统资源, 只拥有一点在运行中必不可少的资源(如程序计数器, 一组寄存器和栈), 但是它可与同属一个进程的其他的线程共享进程所拥有的全部资源. </p>
<p> 一个线程可以创建和撤销另一个线程; 同一个进程中的多个线程之间可以并发执行. </p>
<p> 进程和线程的主要差别在于它们是不同的操作系统资源管理方式. 进程有独立的地址空间, 一个进程崩溃后, 在保护模式下不会对其它进程产生影响. 而线程只是一个进程中的不同执行路径. 线程有自己的堆栈和局部变量, 但线程之间没有单独的地址空间, 一个线程死掉就等于整个进程死掉, 所以多进程的程序要比多线程的程序健壮, 但在进程切换时, 耗费资源较大, 效率要差一些. 但对于一些要求同时进行并且又要共享某些变量的并发操作, 只能用线程, 不能用进程. </p>
<pre><code> 1. 简而言之, 一个程序至少有一个进程, 一个进程至少有一个线程.
 2. 线程的划分尺度小于进程, 使得多线程程序的并发性高. 
 3. 另外, 进程在执行过程中拥有独立的内存单元, 而多个线程共享内存, 从而极大地提高了程序的运行效率. 
 4. 线程在执行过程中与进程还是有区别的. 每个独立的线程有一个程序运行的入口, 顺序执行序列和程序的出口. 但是线程不能够独立执行, 必须依存在应用程序中, 由应用程序提供多个线程执行控制. 
 5. 从逻辑角度来看, 多线程的意义在于一个应用程序中, 有多个执行部分可以同时执行. 但操作系统并没有将多个线程看做多个独立的应用, 来实现进程的调度和管理以及资源分配. 这就是进程和线程的重要区别.
</code></pre><p> 打个比方, 多进程就好比同时执行多个程序. 比如同时运行QQ, 音乐播放器, 以及浏览器. 多线程就是同一时刻执行多个线程, 用浏览器一边下载, 一边听歌, 一边看视频, 一边看网页. 浏览器这个进程下有多个线程, 这些线程共享系统分配给浏览器这个进程的资源, 所以各个线程之间可很方便的通信, 一个线程死了, 不会影响其他线程的运行. 如果浏览器这个进程死了, 那么他下面的所有线程就都用不了了. 我们可以通过浏览器打开QQ这里就是进程间通信, 由于不同的进程系统资源不同, 所以进程间的通信不是很容易实现. 并且切换进程会有性能问题.</p>
</li>
<li><p>并发和并行</p>
<p> 并发指能够让多个任务在逻辑上交织执行的程序设计, 但并发事件之间不一定要同一时刻发生. 并行指的是程序运行时的状态是物理上同时执行, 是指同时发生的两个并发事件, 具有并发的含义, 而并发则不一定并行. </p>
<p> 并发是一种现象, 面对这一现象, 我们首先创建多个线程. 真正加快程序运行速度的, 是并行技术. 也就是让多个CPU同时工作. 而多线程, 是为了让多个CPU同时工作成为可能. 并发设计让并发执行成为可能, 而并行是并发执行的一种模式.</p>
<p> 并发和并行的区别就是一个人同时吃三个馒头和三个人同时吃三个馒头. 一个人同时吃三个馒头但是同一时间只能啃一个馒头, 三个人同时吃三个馒头, 三个馒头同一时间都会被啃.</p>
<p> 下图反映了一个包含8个操作的任务在一个有两核心的CPU中创建四个线程运行的情况. 假设每个核心有两个线程, 那么每个CPU中两个线程会交替并发, 两个CPU之间的操作会并行运算. 就CPU1而言虽然实现了并发但是同一时间只有一个任务在进行, CPU只是快速的在任务之间切换, CPU1和CPU2整体来看是并行元算, 同一时间是有多个任务在进行. 单就一个CPU而言两个线程可以解决线程阻塞造成的不流畅问题, 其本身运行效率并没有提高. 多CPU的并行运算才真正解决了运行效率问题, 这也正是并发和并行的区别. </p>
<p> <img src="http://img.souche.com/f2e/5d7717afde012bbfc557f26bc5eaffea.png" alt="并发和并行"></p>
<p> 注意: 并行和串行是相对应的. 串行在物理层面上同一时刻只会有一个任务在进行.</p>
</li>
<li><p>同步和异步</p>
<p> 同步在发出一个同步调用时, 在没有得到结果之前, 该调用就不返回. 多个任务情况下, 一个任务A执行结束, 才可以执行另一个任务B. 只存在一个线程. 异步在发出一个异步调用后, 调用者不会立刻得到结果, 该调用就返回了. 多个任务情况下, 一个任务A正在执行, 同时可以执行另一个任务B. 任务B不用等待任务A结束才执行. 存在多条线程. </p>
</li>
</ol>
<h2 id="多线程实现方案"><a href="#多线程实现方案" class="headerlink" title="多线程实现方案"></a>多线程实现方案</h2><p>在iOS开发中常见的多线程方案一共有4套, 分别是<code>Pthreads</code>, <code>NSThread</code>, <code>GCD</code>, <code>NSOperation &amp; NSOperationQueue</code>. 前两种不怎么常用, 这里就简单的介绍一下, 着重介绍后两种. </p>
<h3 id="Pthresds"><a href="#Pthresds" class="headerlink" title="Pthresds"></a>Pthresds</h3><p>POSIX线程(POSIX threads), 简称Pthreads, 是线程的POSIX标准. 该标准定义了创建和操纵线程的一整套API, 在类Unix操作系统(Unix、Linux、Mac OSX等)中, 都使用Pthreads作为操作系统的线程. 那也就意味着可以跨平台使用, 但是使用起来特别酸爽. 🙂</p>
<pre><code>#import &lt;pthread.h&gt;

- (void)pthreadsDoTask {
    /*
     pthread_t：线程指针
     pthread_attr_t：线程属性
     pthread_mutex_t：互斥对象
     pthread_mutexattr_t：互斥属性对象
     pthread_cond_t：条件变量
     pthread_condattr_t：条件属性对象
     pthread_key_t：线程数据键
     pthread_rwlock_t：读写锁
     //
     pthread_create()：创建一个线程
     pthread_exit()：终止当前线程
     pthread_cancel()：中断另外一个线程的运行
     pthread_join()：阻塞当前的线程, 直到另外一个线程运行结束
     pthread_attr_init()：初始化线程的属性
     pthread_attr_setdetachstate()：设置脱离状态的属性（决定这个线程在终止时是否可以被结合）
     pthread_attr_getdetachstate()：获取脱离状态的属性
     pthread_attr_destroy()：删除线程的属性
     pthread_kill()：向线程发送一个信号
     pthread_equal(): 对两个线程的线程标识号进行比较
     pthread_detach(): 分离线程
     pthread_self(): 查询线程自身线程标识号
     //
     *创建线程
     int pthread_create(pthread_t _Nullable * _Nonnull __restrict, //指向新建线程标识符的指针
     const pthread_attr_t * _Nullable __restrict,  //设置线程属性. 默认值NULL. 
     void * _Nullable (* _Nonnull)(void * _Nullable),  //该线程运行函数的地址
     void * _Nullable __restrict);  //运行函数所需的参数
     *返回值：
     *若线程创建成功, 则返回0
     *若线程创建失败, 则返回出错编号
     */

    //
    pthread_t thread = NULL;
    NSString *params = @&quot;Hello World&quot;;
    int result = pthread_create(&amp;thread, NULL, threadTask, (__bridge void *)(params));
    result == 0 ? NSLog(@&quot;creat thread success&quot;) : NSLog(@&quot;creat thread failure&quot;);
    //设置子线程的状态设置为detached,则该线程运行结束后会自动释放所有资源
    pthread_detach(thread);
}

void *threadTask(void *params) {
    NSLog(@&quot;%@ - %@&quot;, [NSThread currentThread], (__bridge NSString *)(params));
    return NULL;
}
</code></pre><p>看下这些API设计可以说是相当不友好, 并且需要手动管理线程的各个状态的转换和生命周期的管理.</p>
<h3 id="NSThread"><a href="#NSThread" class="headerlink" title="NSThread"></a>NSThread</h3><p><code>NSThread</code>的API设计大致如下: </p>
<pre><code>@interface NSThread : NSObject
//当前线程
@property (class, readonly, strong) NSThread *currentThread;
//使用类方法创建线程执行任务
+ (void)detachNewThreadWithBlock:(void (^)(void))block API_AVAILABLE(macosx(10.12), ios(10.0), watchos(3.0), tvos(10.0));
+ (void)detachNewThreadSelector:(SEL)selector toTarget:(id)target withObject:(nullable id)argument;
//判断当前是否为多线程
+ (BOOL)isMultiThreaded;
//指定线程的线程参数, 例如设置当前线程的断言处理器. 
@property (readonly, retain) NSMutableDictionary *threadDictionary;
//当前线程暂停到某个时间
+ (void)sleepUntilDate:(NSDate *)date;
//当前线程暂停一段时间
+ (void)sleepForTimeInterval:(NSTimeInterval)ti;
//退出当前线程
+ (void)exit;
//当前线程优先级
+ (double)threadPriority;
//设置当前线程优先级
+ (BOOL)setThreadPriority:(double)p;
//指定线程对象优先级 0.0～1.0, 默认值为0.5
@property double threadPriority NS_AVAILABLE(10_6, 4_0);
//服务质量
@property NSQualityOfService qualityOfService NS_AVAILABLE(10_10, 8_0);
//线程名称
@property (nullable, copy) NSString *name NS_AVAILABLE(10_5, 2_0);
//栈区大小
@property NSUInteger stackSize NS_AVAILABLE(10_5, 2_0);
//是否为主线程
@property (class, readonly) BOOL isMainThread NS_AVAILABLE(10_5, 2_0);
//获取主线程
@property (class, readonly, strong) NSThread *mainThread NS_AVAILABLE(10_5, 2_0);
//初始化
- (instancetype)init NS_AVAILABLE(10_5, 2_0) NS_DESIGNATED_INITIALIZER;
//实例方法初始化, 需要再调用start方法
- (instancetype)initWithTarget:(id)target selector:(SEL)selector object:(nullable id)argument NS_AVAILABLE(10_5, 2_0);
- (instancetype)initWithBlock:(void (^)(void))block API_AVAILABLE(macosx(10.12), ios(10.0), watchos(3.0), tvos(10.0));
//线程状态, 正在执行
@property (readonly, getter=isExecuting) BOOL executing NS_AVAILABLE(10_5, 2_0);
//线程状态, 正在完成
@property (readonly, getter=isFinished) BOOL finished NS_AVAILABLE(10_5, 2_0);
//线程状态, 已经取消
@property (readonly, getter=isCancelled) BOOL cancelled NS_AVAILABLE(10_5, 2_0);
//取消, 仅仅改变线程状态, 并不能像exist一样真正的终止线程
- (void)cancel NS_AVAILABLE(10_5, 2_0);
//开始
- (void)start NS_AVAILABLE(10_5, 2_0);
//线程需要执行的代码, 一般写子类的时候会用到
- (void)main NS_AVAILABLE(10_5, 2_0);
@end

还有一个NSObject的分类
@interface NSObject (NSThreadPerformAdditions)
//隐式的创建并启动线程, 并在指定的线程（主线程或子线程）上执行方法. 
- (void)performSelectorOnMainThread:(SEL)aSelector withObject:(nullable id)arg waitUntilDone:(BOOL)wait modes:(nullable NSArray&lt;NSString *&gt; *)array;
- (void)performSelectorOnMainThread:(SEL)aSelector withObject:(nullable id)arg waitUntilDone:(BOOL)wait;
- (void)performSelector:(SEL)aSelector onThread:(NSThread *)thr withObject:(nullable id)arg waitUntilDone:(BOOL)wait modes:(nullable NSArray&lt;NSString *&gt; *)array NS_AVAILABLE(10_5, 2_0);
- (void)performSelector:(SEL)aSelector onThread:(NSThread *)thr withObject:(nullable id)arg waitUntilDone:(BOOL)wait NS_AVAILABLE(10_5, 2_0);
- (void)performSelectorInBackground:(SEL)aSelector withObject:(nullable id)arg NS_AVAILABLE(10_5, 2_0);
@end
</code></pre><p>常见的用法有以下几种: </p>
<pre><code>- (void) startThread {

    //创建并且手动启动
    NSThread *thread = [[NSThread alloc] initWithTarget:self selector:@selector(run) object:nil];
    [thread start];

    //类方法创建并且自动启动
    [NSThread detachNewThreadSelector:@selector(run) toTarget:self withObject:nil];

    //通过NSObject的方法自动启动
    [self performSelectorInBackground:@selector(run) withObject:nil];
}    

- (void)run {
    NSLog(@&quot;%@&quot;, [NSThread currentThread]);
}
</code></pre><h3 id="GCD"><a href="#GCD" class="headerlink" title="GCD"></a>GCD</h3><p>Grand Central Dispatch, 它是苹果为多核的并行运算提出的解决方案, 会自动合理地利用更多的CPU内核(比如双核、四核), 最重要的是它会自动管理线程的生命周期(创建线程、调度任务、销毁线程), 完全不需要我们管理, 我们只需要告诉干什么就行. 同时它使用的也是C语言, 不过由于使用了Block(Swift里叫做闭包), 使得使用起来更加方便, 而且灵活.</p>
<p>了解GCD我们需要先了解两个概念, <strong><code>队列</code></strong>和<strong><code>任务</code></strong>.</p>
<ol>
<li><p>任务</p>
<p> 要执行的操作或方法函数. 在GCD中指的就是block块, 在NSThread中指的是<code>performSelector:</code>中的方法. 加入任务时有两种形式: <code>同步任务(dispatch_sync)</code>和<code>异步任务(dispatch_async)</code>.</p>
<ol>
<li>同步任务: 不会开启新的线程, 会阻塞当前线程. 完成需要做的任务后才会返回, 进行下一任务. 创建方式为:<pre><code>  //把右边的参数(任务)提交给左边的参数(队列)进行执行
  dispatch_sync(dispatch_queue_t queue, dispatch_block_t block);
</code></pre></li>
<li><p>异步任务: 不会等待任务完成才返回, 会立即返回. 异步是多线程的代名词, 因为必定会开启新的线程, 线程的申请是由异步负责, 起到开分支的作用. 创建方式为:</p>
<pre><code>  //把右边的参数(任务)提交给左边的参数(队列)进行执行
  dispatch_async(dispatch_queue_t queue, dispatch_block_t block);
</code></pre></li>
</ol>
</li>
<li><p>队列</p>
<p> 存放任务的集合, 我们要做的就是将任务添加到队列然后执行, GCD会自动将队列中的任务按先进先出的方式取出. 队列主要有的有<code>串行队列(Serial Dispatch Queue)</code>, <code>并行队列(Concurrent Dispatch Queue)</code>, <code>全局队列(Global Queue)</code>和<code>主队列(Main Queue)</code>.</p>
<ol>
<li><p>串行队列: 任务依次执行, 同一时间队列中只有一个任务在执行, 每个任务只有在前一个任务执行完成后才能开始执行. 你不知道在一个Block(任务)执行结束到下一个Block(任务)开始执行之间的这段时间时间是多长, 这部分是由GCD控制. 创建方式为:</p>
<pre><code>  //创建一个名为queue的串行队列
  //第一个参数为队列名称
  //第二个参数为队列类型, DISPATCH_QUEUE_SERIAL和NULL表示串行队列
  dispatch_queue_t queue = dispatch_queue_create(&quot;com.private.SerialQueue&quot;, DISPATCH_QUEUE_SERIAL);
</code></pre></li>
<li><p>并行队列: 任务并发执行, 唯一能保证的是, 这些任务会按照被添加的顺序开始执行. 但是任务可以以任何顺序完成, 你不知道在执行下一个任务是从什么时候开始, 或者说任意时刻有多个Block(任务)运行, 这个完全是取决于GCD. GCD默认已经提供了全局的并发队列, 供整个应用使用, 一般不需要手动创建创建方式为:</p>
<pre><code>  //创建一个名为queue的并行队列
  //第一个参数为队列名称
  //第二个参数为队列类型, DISPATCH_QUEUE_CONCURRENT表示并行队列
  dispatch_queue_t queue = dispatch_queue_create(&quot;com.private.ConcurrentQueue&quot;,DISPATCH_QUEUE_CONCURRENT);
</code></pre></li>
<li><p>全局队列: <strong>隶属于并行队列</strong>, 不要与 barrier 栅栏方法搭配使用, barrier 只有与自定义的并行队列一起使用, 才能让 barrier 达到我们所期望的栅栏功能. 与串行队列或者global队列 一起使用, barrier的表现会和dispatch_sync方法一样. 创建方式为:</p>
<pre><code>  //获取系统全局队列, 并赋值给队列queue
  //第一个参数表示优先级, 这里是新老优先级的对照Map
  *  - DISPATCH_QUEUE_PRIORITY_HIGH:         QOS_CLASS_USER_INITIATED//高
  *  - DISPATCH_QUEUE_PRIORITY_DEFAULT:      QOS_CLASS_DEFAULT//默认
  *  - DISPATCH_QUEUE_PRIORITY_LOW:          QOS_CLASS_UTILITY//低
  *  - DISPATCH_QUEUE_PRIORITY_BACKGROUND:   QOS_CLASS_BACKGROUND//后台

  //第二个参数是预留参数, 传0就好
  dispatch_queue_t queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);
</code></pre></li>
<li><p>主队列: <strong>隶属于串行队列</strong>, 不能与sync同步方法搭配使用, 会造成死循环. 主队列是GCD自带的一种特殊的串行队列, 放在主队列中的任务, 都会放到主线程中执行. 创建方式为:</p>
<pre><code>  //获取系统主队列, 并赋值给队列queue
  dispatch_queue_t queue = dispatch_get_main_queue();
</code></pre></li>
</ol>
</li>
</ol>
<p>不管是串行队列(SerialQueue)还是并行队列(ConcurrencyQueue), 都是FIFO队列. 也就意味着, 任务一定是一个一个地, 按照先进先出的顺序来执行.</p>
<hr>
<p>参考资料:</p>
<p>1.<a href="http://www.cocoachina.com/ios/20150731/12819.html" target="_blank" rel="external">关于iOS多线程, 你看我就够了</a></p>
<p>2.<a href="https://bestswifter.com/multithreadconclusion/" target="_blank" rel="external">iOS多线程编程总结</a></p>
<p>3.<a href="http://www.jianshu.com/p/51fd1362249e" target="_blank" rel="external">关于iOS多线程, 我说, 你听, 没准你就懂了</a></p>
<p>4.<a href="http://www.jianshu.com/p/06a18323d9d2" target="_blank" rel="external">深入理解 GCD</a></p>
<p>5.<a href="http://www.jianshu.com/p/6a6722f12fe3" target="_blank" rel="external">关于 iOS 多线程, 都在这里了</a></p>
<p>6.<a href="http://blog.csdn.net/mxsgoden/article/details/8821936" target="_blank" rel="external">进程与线程的区别</a></p>
<p>7.<a href="https://laike9m.com/blog/huan-zai-yi-huo-bing-fa-he-bing-xing,61/" target="_blank" rel="external">并发和并行</a></p>

    
  </div>
</article>

</div>





  <a id="backTop" class="back-top">
    <i class="icon-angle-up"></i>
  </a>




  <div class="modal" id="modal">
  <span id="cover" class="cover hide"></span>
  <div id="modal-dialog" class="modal-dialog hide-dialog">
    <div class="modal-header">
      <span id="close" class="btn-close">关闭</span>
    </div>
    <hr>
    <div class="modal-body">
      <ul class="list-toolbox">
        
          <li class="item-toolbox">
            <a
              class="ROUND_RECT"
              href="/archives/"
              rel="noopener noreferrer"
              target="_self"
              >
              博客
            </a>
          </li>
        
          <li class="item-toolbox">
            <a
              class="ROUND_RECT"
              href="/category/"
              rel="noopener noreferrer"
              target="_self"
              >
              分类
            </a>
          </li>
        
          <li class="item-toolbox">
            <a
              class="ROUND_RECT"
              href="/tag/"
              rel="noopener noreferrer"
              target="_self"
              >
              标签
            </a>
          </li>
        
          <li class="item-toolbox">
            <a
              class="ROUND_RECT"
              href="/Wiki/"
              rel="noopener noreferrer"
              target="_self"
              >
              Wiki
            </a>
          </li>
        
          <li class="item-toolbox">
            <a
              class="ROUND_RECT"
              href="/about/"
              rel="noopener noreferrer"
              target="_self"
              >
              关于
            </a>
          </li>
        
          <li class="item-toolbox">
            <a
              class="ROUND_RECT"
              href="/search/"
              rel="noopener noreferrer"
              target="_self"
              >
              搜索
            </a>
          </li>
        
      </ul>

    </div>
  </div>
</div>



  
      <div class="fexo-comments comments-post">
    
  <section class="disqus-comments">
    <div id="disqus_thread">
      <noscript>Please enable JavaScript to view the <a href="//disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
    </div>
  </section>

  <script>
    var disqus_shortname = 'forsigner';
    
    var disqus_url = 'http://hchong.net/2017/11/21/iOS多线程/';
    
    (function(){
      var dsq = document.createElement('script');
      dsq.type = 'text/javascript';
      dsq.async = true;
      dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
      (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    })();
  </script>

  <script id="dsq-count-scr" src="//forsigner.disqus.com/count.js" async></script>



    




  </div>

  

  <script type="text/javascript">
  function loadScript(url, callback) {
    var script = document.createElement('script')
    script.type = 'text/javascript';

    if (script.readyState) { //IE
      script.onreadystatechange = function() {
        if (script.readyState == 'loaded' ||
          script.readyState == 'complete') {
          script.onreadystatechange = null;
          callback();
        }
      };
    } else { //Others
      script.onload = function() {
        callback();
      };
    }

    script.src = url;
    document.getElementsByTagName('head')[0].appendChild(script);
  }

  window.onload = function() {
    loadScript('/js/bundle.js?235683', function() {
      // load success
    });
  }
</script>

</body>
</html>
